Gitz {
  // Top-level
  Program         = Statement*                                      --program

  // Statements
  Statement =
      VarDecl                                                   --stmtVarDecl
    | ListDecl                                                  --stmtListDecl
    | FunDecl                                                   --stmtFunDecl
    | Assignment                                                --stmtAssignment
    | FunCallStatement                                          --stmtFunCall
    | ReturnStmt                                                --stmtReturn
    | IfStmt                                                    --stmtIf
    | LoopStmt                                                  --stmtLoop
    | TryStmt                                                   --stmtTry
    | BreakStmt                                                 --stmtBreak
    | ContinueStmt                                              --stmtContinue
    | SayStmt                                                   --stmtSay
    | "(" Exp ")" ";"                                           --parenStmt

  FunCallStatement = FunCall ";"                                --funCallStmt
  BreakStmt        = "Break" ";"                                --breakStmt
  ContinueStmt     = "Skip" ";"                                 --continueStmt
  SayStmt          = "say" "(" ExpList? ")" ";"                 --sayStmt

  // Declarations
  VarDecl    = "Make" id ":" Type Initialiser? ";"              --varDecl
  ListDecl   = "Make" id ":" ListType Initialiser? ";"          --listDecl
  Initialiser = "=" Exp                                         --init

  // Functions
  FunDecl    = "Show" id Params ("->" Type)? Block              --funDecl
  Params     = "(" ParamList? ")"                               --params
  ParamList  = Param ("," Param)*                              --paramList
  Param      = id ":" Type                                      --param

  // Return
  ReturnStmt = "give" Exp? ";"                                  --returnStmt

  // Conditionals
  IfStmt     = "When" Exp Block (OrWhenClause)* ("orElse" Block)? --ifStmt
  OrWhenClause = "orWhen" Exp Block                             --orWhenClause

  // Loops
  LoopStmt   = "Keep" id "in" Exp Block                          --loopForEach
             | "Keep" Exp Block                                --loopWhile

  // Assignments & indexing
  Assignment      = (id | IndexedAccess) "=" Exp ";"            --assignValid
                  | IntLit "=" Exp ";"                         --assignInvalid
  IndexedAccess   = id "[" Exp "]"                              --index

  // Function calls (expressions vs statements)
  FunCall     = id "(" ArgList ")"                              --funCallArgs
              | id "(" ")"                                      --funCallNoArgs
  ArgList     = Exp ("," Exp)*                                  --argList

  // Exception handling
  TryStmt     = "Try" Block "Catch" id Block                    --tryStmt

  // Blocks
  Block       = "{" (Statement | FunDecl)* "}"                  --block

  // Expressions
  Exp                 = ConditionalExp                          --exp

  ConditionalExp      = LogicalOrExp                            --conditional

  LogicalOrExp        = LogicalAndExp ("or" LogicalAndExp)*     --lor
  LogicalAndExp       = EqualityExp ("and" EqualityExp)*        --land
  EqualityExp         = RelationalExp (EqualityOp RelationalExp)* --eqExp
  EqualityOp          = "==" | "!=" | "equal" | "notSame"       --eqOp
  RelationalExp       = AdditiveExp (RelOp AdditiveExp)*        --relExp
  RelOp               = "<" | ">" | "bigger" | "smaller" | "in" --relOp
  AdditiveExp         = MultiplicativeExp (AddOp MultiplicativeExp)* --addExp
  AddOp               = "plus" | "minus"                        --addOp
  MultiplicativeExp   = UnaryExp (MulOp UnaryExp)*              --mulExp
  MulOp               = "times" | "over" | "mod"                --mulOp

  UnaryExp            = ("minus" | "not")? PrimaryExp            --unary

  PrimaryExp =
      "(" Exp ")"                                               --parens
    | FunCall                                                  --primaryFunCall
    | IndexedAccess                                            --primaryIndex
    | id                                                       --primaryId
    | FloatLit                                                 --primaryFloat
    | IntLit                                                   --primaryInt
    | StringLit                                                --primaryString
    | ListExp                                                  --primaryList
    | booleanLiteral                                           --primaryBool

  booleanLiteral      = "true" | "false"

  // Types
  Type                = BasicType | ListType                    --type
  BasicType           = "num" | "text" | "bool" | id            --basicType
  ListType            = "list" "[" Type "]"                     --listTypeSquare
                      | "list" "<" Type ">"                     --listTypeAngle

  // Identifiers & literals
  id                  = ~reservedKeyword letter alnum*         --identifier
  IntLit              = digit+                                --intLit
  FloatLit            = digit+ "." digit+ ExpPart?            --floatFull
                      | digit+ "." ExpPart?                   --floatTrailingDot
                      | "." digit+ ExpPart?                   --floatLeadingDot
  ExpPart             = "E" ("+" | "-")? digit+               --expPart
  StringLit           = "\"" Char* "\""                        --stringClosed
                      | "\"" Char*                            --stringUnclosed

  ListExp             = "[" ExpList? "]"                       --listExp
  ExpList             = Exp ("," Exp)*                         --expList

  Char                = NormalChar | EscapeSeq | UnicodeEscape --char
  NormalChar          = ~Control ~"\\" ~"\"" any               --normalChar
  EscapeSeq           = "\\" ("n" | "t" | "\"" | "\\")        --escapeSeq
  UnicodeEscape       = "\\u{" hexDigit+ "}"                  --unicodeEscape

  Control             = "\x00".."\x1f" | "\x80".."\x9f"         --control

  // Keywords
  reservedKeyword     =
      "Make" | "list" | "Show" | "When" | "Keep" | "orWhen"
    | "orElse" | "give" | "say" | "Break" | "Skip" | "Try"
    | "Catch"                                                     --reservedKeyword

  // Comments & whitespace
  space += comment | multiLineComment

  comment             = "#" (~"\n" any)*                       --lineComment
  multiLineComment    = "/*" (~"*/" any)* "*/"                --blockComment
}
